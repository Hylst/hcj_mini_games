<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkers Classic Reborn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes capture {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        @keyframes crown {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        
        .pulse-animation {
            animation: pulse 1.5s infinite;
        }
        
        .capture-animation {
            animation: capture 0.5s forwards;
        }
        
        .crown-animation {
            animation: crown 0.5s forwards;
        }
        
        .checker-piece {
            transition: all 0.3s ease;
            cursor: grab;
        }
        
        .checker-piece:active {
            cursor: grabbing;
        }
        
        .valid-move {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
        }
        
        .board-cell {
            position: relative;
        }
        
        .board-cell::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .board-cell:hover::after {
            opacity: 1;
        }
        
        .theme-selector {
            transition: all 0.3s ease;
        }
        
        .theme-selector:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="max-w-4xl w-full">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Checkers Classic Reborn</h1>
            <p class="text-gray-600">A modern take on the classic board game</p>
        </header>
        
        <div class="flex flex-col lg:flex-row gap-8 items-center lg:items-start justify-center">
            <!-- Game board -->
            <div class="relative">
                <div id="board" class="bg-gray-800 p-4 rounded-lg shadow-2xl">
                    <!-- Board will be generated by JavaScript -->
                </div>
                
                <div id="game-over" class="absolute inset-0 bg-black bg-opacity-70 flex flex-col items-center justify-center rounded-lg hidden">
                    <h2 class="text-white text-3xl font-bold mb-4" id="game-over-message">Player Wins!</h2>
                    <button id="play-again" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full transition-all">
                        Play Again
                    </button>
                </div>
            </div>
            
            <!-- Game controls and info -->
            <div class="bg-white p-6 rounded-lg shadow-lg w-full lg:w-64">
                <div class="mb-6">
                    <h2 class="text-xl font-bold text-gray-800 mb-3">Game Info</h2>
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium">Player (Red):</span>
                        <span id="player-score" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between items-center mb-4">
                        <span class="font-medium">Computer (Black):</span>
                        <span id="computer-score" class="font-bold">0</span>
                    </div>
                    <div class="h-1 bg-gray-200 rounded-full mb-2">
                        <div id="turn-indicator" class="h-1 bg-blue-500 rounded-full w-1/2"></div>
                    </div>
                    <p id="turn-text" class="text-sm text-center">Your turn</p>
                </div>
                
                <div class="mb-6">
                    <h2 class="text-xl font-bold text-gray-800 mb-3">Difficulty</h2>
                    <div class="flex gap-2">
                        <button id="easy" class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-medium hover:bg-green-200 transition-all">Easy</button>
                        <button id="medium" class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm font-medium hover:bg-yellow-200 transition-all">Medium</button>
                        <button id="hard" class="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm font-medium hover:bg-red-200 transition-all">Hard</button>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h2 class="text-xl font-bold text-gray-800 mb-3">Theme</h2>
                    <div class="flex gap-3 justify-center">
                        <div class="theme-selector cursor-pointer" data-theme="classic">
                            <div class="w-10 h-10 bg-amber-800 rounded"></div>
                            <p class="text-xs text-center mt-1">Classic</p>
                        </div>
                        <div class="theme-selector cursor-pointer" data-theme="modern">
                            <div class="w-10 h-10 bg-gray-800 rounded"></div>
                            <p class="text-xs text-center mt-1">Modern</p>
                        </div>
                        <div class="theme-selector cursor-pointer" data-theme="nature">
                            <div class="w-10 h-10 bg-green-800 rounded"></div>
                            <p class="text-xs text-center mt-1">Nature</p>
                        </div>
                    </div>
                </div>
                
                <button id="new-game" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full transition-all mb-2">
                    New Game
                </button>
                
                <button id="rules-btn" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-full transition-all">
                    <i class="fas fa-question-circle mr-2"></i> Rules
                </button>
            </div>
        </div>
    </div>
    
    <!-- Rules Modal -->
    <div id="rules-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-lg max-w-md w-full p-6 max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Checkers Rules</h3>
                <button id="close-rules" class="text-gray-500 hover:text-gray-700">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="space-y-3 text-sm">
                <p><strong>1. Starting Position:</strong> Each player starts with 12 pieces on the dark squares of their side.</p>
                <p><strong>2. Movement:</strong> Regular pieces move diagonally forward one square at a time.</p>
                <p><strong>3. Capturing:</strong> If an opponent's piece is adjacent and the square immediately beyond it is empty, you must jump over it, capturing the piece.</p>
                <p><strong>4. Multiple Captures:</strong> If after a capture you can make another capture, you must do so.</p>
                <p><strong>5. Kings:</strong> When a piece reaches the farthest row, it becomes a king and can move both forward and backward.</p>
                <p><strong>6. Winning:</strong> The game is won by capturing all opponent pieces or blocking them so they cannot move.</p>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            const state = {
                board: [],
                currentPlayer: 'red',
                selectedPiece: null,
                validMoves: [],
                playerScore: 0,
                computerScore: 0,
                difficulty: 'medium',
                theme: 'classic',
                gameActive: true
            };
            
            // DOM elements
            const boardElement = document.getElementById('board');
            const playerScoreElement = document.getElementById('player-score');
            const computerScoreElement = document.getElementById('computer-score');
            const turnIndicatorElement = document.getElementById('turn-indicator');
            const turnTextElement = document.getElementById('turn-text');
            const gameOverElement = document.getElementById('game-over');
            const gameOverMessageElement = document.getElementById('game-over-message');
            const playAgainButton = document.getElementById('play-again');
            const newGameButton = document.getElementById('new-game');
            const rulesButton = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const closeRulesButton = document.getElementById('close-rules');
            const difficultyButtons = {
                easy: document.getElementById('easy'),
                medium: document.getElementById('medium'),
                hard: document.getElementById('hard')
            };
            
            // Initialize the game
            initGame();
            
            // Event listeners
            playAgainButton.addEventListener('click', initGame);
            newGameButton.addEventListener('click', initGame);
            rulesButton.addEventListener('click', () => rulesModal.classList.remove('hidden'));
            closeRulesButton.addEventListener('click', () => rulesModal.classList.add('hidden'));
            
            // Difficulty buttons
            Object.keys(difficultyButtons).forEach(difficulty => {
                difficultyButtons[difficulty].addEventListener('click', () => {
                    state.difficulty = difficulty;
                    updateDifficultyButtons();
                });
            });
            
            // Theme selectors
            document.querySelectorAll('.theme-selector').forEach(selector => {
                selector.addEventListener('click', () => {
                    state.theme = selector.dataset.theme;
                    applyTheme();
                });
            });
            
            // Initialize a new game
            function initGame() {
                state.board = createInitialBoard();
                state.currentPlayer = 'red';
                state.selectedPiece = null;
                state.validMoves = [];
                state.gameActive = true;
                
                renderBoard();
                updateScores();
                updateTurnIndicator();
                gameOverElement.classList.add('hidden');
                
                if (state.currentPlayer === 'black') {
                    setTimeout(computerMove, 800);
                }
            }
            
            // Create initial board setup
            function createInitialBoard() {
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Place red pieces (player)
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = { color: 'red', isKing: false };
                        }
                    }
                }
                
                // Place black pieces (computer)
                for (let row = 5; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = { color: 'black', isKing: false };
                        }
                    }
                }
                
                return board;
            }
            
            // Render the board
            function renderBoard() {
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    const rowElement = document.createElement('div');
                    rowElement.className = 'flex';
                    
                    for (let col = 0; col < 8; col++) {
                        const cell = document.createElement('div');
                        cell.className = `w-12 h-12 md:w-16 md:h-16 flex items-center justify-center relative board-cell ${(row + col) % 2 === 0 ? 'bg-gray-100' : 'bg-gray-700'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Highlight valid moves
                        const isMoveValid = state.validMoves.some(move => 
                            move.to.row === row && move.to.col === col
                        );
                        
                        if (isMoveValid) {
                            cell.classList.add('valid-move');
                        }
                        
                        // Add piece if exists
                        if (state.board[row][col]) {
                            const piece = state.board[row][col];
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `checker-piece w-10 h-10 md:w-14 md:h-14 rounded-full flex items-center justify-center ${piece.color === 'red' ? 'bg-red-500' : 'bg-gray-900'} ${piece.isKing ? 'ring-2 ring-yellow-400' : ''}`;
                            
                            if (piece.isKing) {
                                const crownIcon = document.createElement('i');
                                crownIcon.className = 'fas fa-crown text-yellow-400 text-xs md:text-sm';
                                pieceElement.appendChild(crownIcon);
                            }
                            
                            // Add drag events
                            pieceElement.draggable = true;
                            pieceElement.addEventListener('dragstart', handleDragStart);
                            
                            // Add click event for selection
                            pieceElement.addEventListener('click', () => handlePieceClick(row, col));
                            
                            cell.appendChild(pieceElement);
                        } else {
                            // Add drop target for empty cells
                            cell.addEventListener('dragover', handleDragOver);
                            cell.addEventListener('drop', handleDrop);
                            cell.addEventListener('click', () => handleCellClick(row, col));
                        }
                        
                        rowElement.appendChild(cell);
                    }
                    
                    boardElement.appendChild(rowElement);
                }
                
                applyTheme();
            }
            
            // Handle piece selection
            function handlePieceClick(row, col) {
                if (!state.gameActive) return;
                
                const piece = state.board[row][col];
                
                // Only allow selecting current player's pieces
                if (piece.color !== state.currentPlayer) return;
                
                // If same piece is clicked again, deselect it
                if (state.selectedPiece && state.selectedPiece.row === row && state.selectedPiece.col === col) {
                    state.selectedPiece = null;
                    state.validMoves = [];
                    renderBoard();
                    return;
                }
                
                state.selectedPiece = { row, col };
                state.validMoves = getValidMoves(row, col);
                renderBoard();
            }
            
            // Handle empty cell click
            function handleCellClick(row, col) {
                if (!state.selectedPiece || !state.gameActive) return;
                
                const move = state.validMoves.find(m => m.to.row === row && m.to.col === col);
                if (move) {
                    makeMove(move);
                }
            }
            
            // Get all valid moves for a piece
            function getValidMoves(row, col) {
                const piece = state.board[row][col];
                if (!piece) return [];
                
                const moves = [];
                const directions = piece.isKing ? 
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] : 
                    (piece.color === 'red' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]]);
                
                // Check regular moves
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (isValidPosition(newRow, newCol) && !state.board[newRow][newCol]) {
                        moves.push({
                            from: { row, col },
                            to: { row: newRow, col: newCol },
                            capture: null
                        });
                    }
                }
                
                // Check capture moves
                const captureMoves = getCaptureMoves(row, col, piece.color, piece.isKing);
                if (captureMoves.length > 0) {
                    return captureMoves; // In checkers, captures are mandatory
                }
                
                return moves;
            }
            
            // Get all possible capture moves for a piece
            function getCaptureMoves(row, col, color, isKing, currentPath = []) {
                const moves = [];
                const directions = isKing ? 
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] : 
                    (color === 'red' ? [[1, -1], [1, 1]] : [[-1, -1], [-1, 1]]);
                
                for (const [dr, dc] of directions) {
                    const jumpRow = row + dr;
                    const jumpCol = col + dc;
                    const landRow = row + 2 * dr;
                    const landCol = col + 2 * dc;
                    
                    if (isValidPosition(jumpRow, jumpCol) && 
                        isValidPosition(landRow, landCol) &&
                        state.board[jumpRow][jumpCol] && 
                        state.board[jumpRow][jumpCol].color !== color &&
                        !state.board[landRow][landCol] &&
                        !currentPath.some(pos => pos.row === landRow && pos.col === landCol)) {
                        
                        const capturedPiece = { row: jumpRow, col: jumpCol };
                        
                        // Check for multi-capture
                        const newBoard = JSON.parse(JSON.stringify(state.board));
                        newBoard[landRow][landCol] = { ...newBoard[row][col] };
                        newBoard[row][col] = null;
                        newBoard[jumpRow][jumpCol] = null;
                        
                        const furtherCaptures = getCaptureMoves(
                            landRow, landCol, color, isKing, 
                            [...currentPath, { row, col }]
                        );
                        
                        if (furtherCaptures.length > 0) {
                            moves.push(...furtherCaptures);
                        } else {
                            moves.push({
                                from: { row, col },
                                to: { row: landRow, col: landCol },
                                capture: capturedPiece
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            // Check if position is valid
            function isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }
            
            // Make a move
            function makeMove(move) {
                const { from, to, capture } = move;
                const piece = state.board[from.row][from.col];
                
                // Move the piece
                state.board[to.row][to.col] = { ...piece };
                state.board[from.row][from.col] = null;
                
                // Check for king promotion
                if (!piece.isKing && (
                    (piece.color === 'red' && to.row === 7) || 
                    (piece.color === 'black' && to.row === 0)
                )) {
                    state.board[to.row][to.col].isKing = true;
                    
                    // Add crown animation
                    const cell = document.querySelector(`[data-row="${to.row}"][data-col="${to.col}"]`);
                    if (cell) {
                        const pieceElement = cell.querySelector('.checker-piece');
                        if (pieceElement) {
                            pieceElement.classList.add('crown-animation');
                            
                            const crownIcon = document.createElement('i');
                            crownIcon.className = 'fas fa-crown text-yellow-400 text-xs md:text-sm';
                            pieceElement.appendChild(crownIcon);
                            
                            setTimeout(() => {
                                pieceElement.classList.remove('crown-animation');
                            }, 500);
                        }
                    }
                }
                
                // Capture opponent's piece if needed
                if (capture) {
                    // Add capture animation
                    const captureCell = document.querySelector(`[data-row="${capture.row}"][data-col="${capture.col}"]`);
                    if (captureCell) {
                        const capturePiece = captureCell.querySelector('.checker-piece');
                        if (capturePiece) {
                            capturePiece.classList.add('capture-animation');
                        }
                    }
                    
                    setTimeout(() => {
                        state.board[capture.row][capture.col] = null;
                        
                        // Update score
                        if (piece.color === 'red') {
                            state.playerScore++;
                        } else {
                            state.computerScore++;
                        }
                        
                        updateScores();
                        renderBoard();
                        
                        // Check for additional captures
                        const additionalCaptures = getCaptureMoves(
                            to.row, to.col, piece.color, piece.isKing
                        );
                        
                        if (additionalCaptures.length > 0) {
                            state.selectedPiece = { row: to.row, col: to.col };
                            state.validMoves = additionalCaptures;
                            renderBoard();
                            return; // Don't switch turns yet
                        }
                        
                        // Switch turns
                        switchTurn();
                    }, 500);
                } else {
                    renderBoard();
                    switchTurn();
                }
            }
            
            // Switch turns
            function switchTurn() {
                state.selectedPiece = null;
                state.validMoves = [];
                
                state.currentPlayer = state.currentPlayer === 'red' ? 'black' : 'red';
                updateTurnIndicator();
                
                // Check for game over
                if (isGameOver()) {
                    endGame();
                    return;
                }
                
                // Computer's turn
                if (state.currentPlayer === 'black' && state.gameActive) {
                    setTimeout(computerMove, 800);
                }
            }
            
            // Computer move logic
            function computerMove() {
                if (!state.gameActive) return;
                
                // Get all possible moves
                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = state.board[row][col];
                        if (piece && piece.color === 'black') {
                            const moves = getValidMoves(row, col);
                            allMoves.push(...moves);
                        }
                    }
                }
                
                if (allMoves.length === 0) {
                    endGame();
                    return;
                }
                
                // Select move based on difficulty
                let selectedMove;
                if (state.difficulty === 'easy') {
                    // Random move
                    selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                } else if (state.difficulty === 'medium') {
                    // Prefer captures and king promotions
                    const captures = allMoves.filter(m => m.capture);
                    const kingMoves = allMoves.filter(m => 
                        !m.capture && 
                        !state.board[m.from.row][m.from.col].isKing && 
                        m.to.row === 0
                    );
                    
                    if (captures.length > 0) {
                        selectedMove = captures[Math.floor(Math.random() * captures.length)];
                    } else if (kingMoves.length > 0) {
                        selectedMove = kingMoves[Math.floor(Math.random() * kingMoves.length)];
                    } else {
                        selectedMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                    }
                } else {
                    // Hard - try to find the best move
                    const captures = allMoves.filter(m => m.capture);
                    if (captures.length > 0) {
                        // Find capture with most subsequent captures
                        let bestCapture = null;
                        let maxSubCaptures = -1;
                        
                        for (const capture of captures) {
                            const newBoard = JSON.parse(JSON.stringify(state.board));
                            const piece = newBoard[capture.from.row][capture.from.col];
                            
                            // Apply the capture
                            newBoard[capture.to.row][capture.to.col] = { ...piece };
                            newBoard[capture.from.row][capture.from.col] = null;
                            newBoard[capture.capture.row][capture.capture.col] = null;
                            
                            // Check for king promotion
                            if (!piece.isKing && capture.to.row === 0) {
                                newBoard[capture.to.row][capture.to.col].isKing = true;
                            }
                            
                            // Count subsequent captures
                            const subCaptures = getCaptureMoves(
                                capture.to.row, capture.to.col, 
                                piece.color, newBoard[capture.to.row][capture.to.col].isKing
                            ).length;
                            
                            if (subCaptures > maxSubCaptures) {
                                maxSubCaptures = subCaptures;
                                bestCapture = capture;
                            }
                        }
                        
                        selectedMove = bestCapture || captures[0];
                    } else {
                        // No captures, evaluate regular moves
                        const evaluatedMoves = allMoves.map(move => {
                            let score = 0;
                            
                            // Prefer moving pieces to the back row (king promotion)
                            if (!state.board[move.from.row][move.from.col].isKing && move.to.row === 0) {
                                score += 5;
                            }
                            
                            // Prefer moving pieces forward
                            if (state.board[move.from.row][move.from.col].color === 'black') {
                                score += move.from.row - move.to.row; // Black moves up (negative row delta)
                            }
                            
                            // Prefer center control
                            const centerDistance = Math.abs(move.to.col - 3.5) + Math.abs(move.to.row - 3.5);
                            score += (7 - centerDistance) * 0.5;
                            
                            return { move, score };
                        });
                        
                        evaluatedMoves.sort((a, b) => b.score - a.score);
                        selectedMove = evaluatedMoves[0].move;
                    }
                }
                
                // Make the selected move
                makeMove(selectedMove);
            }
            
            // Check if game is over
            function isGameOver() {
                let redHasPieces = false;
                let redCanMove = false;
                let blackHasPieces = false;
                let blackCanMove = false;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = state.board[row][col];
                        if (!piece) continue;
                        
                        if (piece.color === 'red') {
                            redHasPieces = true;
                            if (getValidMoves(row, col).length > 0) {
                                redCanMove = true;
                            }
                        } else {
                            blackHasPieces = true;
                            if (getValidMoves(row, col).length > 0) {
                                blackCanMove = true;
                            }
                        }
                    }
                }
                
                if (!redHasPieces || !redCanMove) return 'black';
                if (!blackHasPieces || !blackCanMove) return 'red';
                return false;
            }
            
            // End the game
            function endGame() {
                state.gameActive = false;
                const winner = isGameOver();
                
                if (winner === 'red') {
                    gameOverMessageElement.textContent = 'You Win!';
                    gameOverMessageElement.className = 'text-white text-3xl font-bold mb-4 text-green-400';
                } else if (winner === 'black') {
                    gameOverMessageElement.textContent = 'Computer Wins!';
                    gameOverMessageElement.className = 'text-white text-3xl font-bold mb-4 text-red-400';
                } else {
                    gameOverMessageElement.textContent = 'Game Over!';
                    gameOverMessageElement.className = 'text-white text-3xl font-bold mb-4 text-yellow-400';
                }
                
                gameOverElement.classList.remove('hidden');
            }
            
            // Update scores display
            function updateScores() {
                playerScoreElement.textContent = state.playerScore;
                computerScoreElement.textContent = state.computerScore;
            }
            
            // Update turn indicator
            function updateTurnIndicator() {
                if (state.currentPlayer === 'red') {
                    turnIndicatorElement.className = 'h-1 bg-blue-500 rounded-full w-full';
                    turnTextElement.textContent = 'Your turn';
                    turnTextElement.className = 'text-sm text-center text-blue-500';
                } else {
                    turnIndicatorElement.className = 'h-1 bg-blue-500 rounded-full w-0';
                    turnTextElement.textContent = 'Computer thinking...';
                    turnTextElement.className = 'text-sm text-center text-gray-500';
                }
            }
            
            // Update difficulty buttons
            function updateDifficultyButtons() {
                Object.keys(difficultyButtons).forEach(difficulty => {
                    if (difficulty === state.difficulty) {
                        difficultyButtons[difficulty].classList.add('ring-2', 'ring-blue-500');
                    } else {
                        difficultyButtons[difficulty].classList.remove('ring-2', 'ring-blue-500');
                    }
                });
            }
            
            // Apply selected theme
            function applyTheme() {
                const cells = document.querySelectorAll('.board-cell');
                cells.forEach(cell => {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if ((row + col) % 2 === 0) {
                        cell.className = cell.className.replace(/bg-\w+-\d+/, 'bg-gray-100');
                    } else {
                        let bgColor;
                        switch (state.theme) {
                            case 'classic':
                                bgColor = 'bg-amber-800';
                                break;
                            case 'modern':
                                bgColor = 'bg-gray-800';
                                break;
                            case 'nature':
                                bgColor = 'bg-green-800';
                                break;
                            default:
                                bgColor = 'bg-amber-800';
                        }
                        cell.className = cell.className.replace(/bg-\w+-\d+/, bgColor);
                    }
                });
            }
            
            // Drag and drop handlers
            function handleDragStart(e) {
                const cell = e.target.closest('[data-row][data-col]');
                if (!cell) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Only allow dragging current player's pieces
                const piece = state.board[row][col];
                if (!piece || piece.color !== state.currentPlayer) {
                    e.preventDefault();
                    return;
                }
                
                // Select the piece if not already selected
                if (!state.selectedPiece || state.selectedPiece.row !== row || state.selectedPiece.col !== col) {
                    state.selectedPiece = { row, col };
                    state.validMoves = getValidMoves(row, col);
                    renderBoard();
                }
                
                e.dataTransfer.setData('text/plain', JSON.stringify({ row, col }));
                e.dataTransfer.effectAllowed = 'move';
                
                // Add visual feedback
                setTimeout(() => {
                    e.target.classList.add('opacity-50');
                }, 0);
            }
            
            function handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }
            
            function handleDrop(e) {
                e.preventDefault();
                
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                const fromRow = data.row;
                const fromCol = data.col;
                const toRow = parseInt(e.target.closest('[data-row]').dataset.row);
                const toCol = parseInt(e.target.closest('[data-col]').dataset.col);
                
                // Find if this is a valid move
                const move = state.validMoves.find(m => 
                    m.from.row === fromRow && 
                    m.from.col === fromCol && 
                    m.to.row === toRow && 
                    m.to.col === toCol
                );
                
                if (move) {
                    makeMove(move);
                }
                
                // Remove visual feedback
                const draggedElement = document.querySelector('.checker-piece.opacity-50');
                if (draggedElement) {
                    draggedElement.classList.remove('opacity-50');
                }
            }
        });
    </script>
</body>
</html>