<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Tic Tac Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes cellPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes winLine {
            0% { width: 0; }
            100% { width: 100%; }
        }
        
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }
        
        .cell-animation {
            animation: cellPop 0.3s ease-out;
        }
        
        .win-line {
            position: absolute;
            height: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 4px;
            animation: winLine 0.5s ease-out forwards;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--color);
            animation: confetti 2s linear forwards;
        }
        
        .theme-selector {
            transition: all 0.3s ease;
        }
        
        .theme-selector:hover {
            transform: scale(1.1);
        }
        
        .theme-selector.active {
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
        }
        
        .difficulty-btn {
            transition: all 0.2s ease;
        }
        
        .difficulty-btn:hover {
            transform: translateY(-2px);
        }
        
        .difficulty-btn.active {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .glow {
            animation: glow 1.5s infinite alternate;
        }
        
        @keyframes glow {
            from {
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            }
            to {
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500" id="body">
    <div class="max-w-4xl w-full">
        <h1 class="text-4xl md:text-5xl font-bold text-center mb-2 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600">
            Advanced Tic Tac Toe
        </h1>
        <p class="text-center text-gray-300 mb-8">By Geoffroy Streit - Hylst</p>
        
        <div class="flex flex-col md:flex-row gap-8">
            <!-- Game board -->
            <div class="flex-1">
                <div class="flex justify-between items-center mb-6">
                    <div class="text-xl">
                        <span class="font-bold text-blue-400">Player (X)</span>: <span id="player-score">0</span>
                    </div>
                    <div class="text-xl">
                        <span class="font-bold text-pink-400">AI (O)</span>: <span id="ai-score">0</span>
                    </div>
                    <div class="text-xl">
                        <span class="font-bold text-gray-400">Draws</span>: <span id="draw-score">0</span>
                    </div>
                </div>
                
                <div class="relative bg-gray-800 rounded-xl p-4 shadow-2xl overflow-hidden">
                    <div class="grid grid-cols-3 gap-3 aspect-square" id="board">
                        <!-- Cells will be generated by JavaScript -->
                    </div>
                    
                    <div class="absolute inset-0 pointer-events-none" id="win-line-container"></div>
                </div>
                
                <div class="mt-6 flex justify-center">
                    <button id="reset-btn" class="px-6 py-2 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full font-bold hover:opacity-90 transition-all transform hover:scale-105">
                        Reset Game
                    </button>
                </div>
            </div>
            
            <!-- Settings panel -->
            <div class="md:w-64 flex flex-col gap-6">
                <div class="bg-gray-800 rounded-xl p-4 shadow-xl">
                    <h2 class="text-xl font-bold mb-4 text-center">Difficulty</h2>
                    <div class="flex flex-col gap-2">
                        <button class="difficulty-btn px-4 py-2 bg-green-600 rounded-lg" data-difficulty="easy">Easy</button>
                        <button class="difficulty-btn px-4 py-2 bg-yellow-600 rounded-lg active" data-difficulty="medium">Medium</button>
                        <button class="difficulty-btn px-4 py-2 bg-red-600 rounded-lg" data-difficulty="hard">Hard</button>
                    </div>
                </div>
                
                <div class="bg-gray-800 rounded-xl p-4 shadow-xl">
                    <h2 class="text-xl font-bold mb-4 text-center">Theme</h2>
                    <div class="grid grid-cols-3 gap-3">
                        <div class="theme-selector aspect-square bg-gradient-to-br from-gray-900 to-gray-800 rounded-lg cursor-pointer active" data-theme="default"></div>
                        <div class="theme-selector aspect-square bg-gradient-to-br from-blue-900 to-blue-700 rounded-lg cursor-pointer" data-theme="blue"></div>
                        <div class="theme-selector aspect-square bg-gradient-to-br from-purple-900 to-purple-700 rounded-lg cursor-pointer" data-theme="purple"></div>
                        <div class="theme-selector aspect-square bg-gradient-to-br from-green-900 to-green-700 rounded-lg cursor-pointer" data-theme="green"></div>
                        <div class="theme-selector aspect-square bg-gradient-to-br from-red-900 to-red-700 rounded-lg cursor-pointer" data-theme="red"></div>
                        <div class="theme-selector aspect-square bg-gradient-to-br from-yellow-900 to-yellow-700 rounded-lg cursor-pointer" data-theme="yellow"></div>
                    </div>
                </div>
                
                <div class="bg-gray-800 rounded-xl p-4 shadow-xl">
                    <h2 class="text-xl font-bold mb-4 text-center">Game Status</h2>
                    <div class="text-center py-4">
                        <p id="game-status" class="text-lg">Your turn (X)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            let board = ['', '', '', '', '', '', '', '', ''];
            let currentPlayer = 'X';
            let gameActive = true;
            let scores = { player: 0, ai: 0, draw: 0 };
            let difficulty = 'medium';
            let theme = 'default';
            
            // DOM elements
            const boardElement = document.getElementById('board');
            const winLineContainer = document.getElementById('win-line-container');
            const resetBtn = document.getElementById('reset-btn');
            const playerScoreElement = document.getElementById('player-score');
            const aiScoreElement = document.getElementById('ai-score');
            const drawScoreElement = document.getElementById('draw-score');
            const gameStatusElement = document.getElementById('game-status');
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const themeSelectors = document.querySelectorAll('.theme-selector');
            const bodyElement = document.getElementById('body');
            
            // Initialize the board
            function initializeBoard() {
                boardElement.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('bg-gray-700', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-6xl', 'font-bold', 'cursor-pointer', 'transition-all', 'hover:bg-gray-600');
                    cell.dataset.index = i;
                    cell.addEventListener('click', () => handleCellClick(i));
                    boardElement.appendChild(cell);
                }
            }
            
            // Handle cell click
            function handleCellClick(index) {
                if (!gameActive || board[index] !== '') return;
                
                // Player move
                makeMove(index, currentPlayer);
                
                // Check for win or draw
                if (checkWin(board, currentPlayer)) {
                    handleWin(currentPlayer);
                    return;
                }
                
                if (checkDraw()) {
                    handleDraw();
                    return;
                }
                
                // Switch to AI
                currentPlayer = 'O';
                updateGameStatus(`AI's turn (O)`);
                
                // AI move with delay for better UX
                setTimeout(() => {
                    const aiMove = getAIMove();
                    makeMove(aiMove, currentPlayer);
                    
                    if (checkWin(board, currentPlayer)) {
                        handleWin(currentPlayer);
                        return;
                    }
                    
                    if (checkDraw()) {
                        handleDraw();
                        return;
                    }
                    
                    // Switch back to player
                    currentPlayer = 'X';
                    updateGameStatus(`Your turn (X)`);
                }, 500);
            }
            
            // Make a move on the board
            function makeMove(index, player) {
                board[index] = player;
                const cell = boardElement.children[index];
                
                // Add animation class
                cell.classList.add('cell-animation');
                
                // Set the player symbol
                cell.textContent = player;
                
                // Set color based on player
                if (player === 'X') {
                    cell.classList.add('text-blue-400');
                } else {
                    cell.classList.add('text-pink-400');
                }
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    cell.classList.remove('cell-animation');
                }, 300);
            }
            
            // Check for win
            function checkWin(board, player) {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6]             // diagonals
                ];
                
                return winPatterns.some(pattern => {
                    const [a, b, c] = pattern;
                    return board[a] === player && board[b] === player && board[c] === player;
                });
            }
            
            // Check for draw
            function checkDraw() {
                return board.every(cell => cell !== '');
            }
            
            // Handle win
            function handleWin(winner) {
                gameActive = false;
                
                // Update scores
                if (winner === 'X') {
                    scores.player++;
                    playerScoreElement.textContent = scores.player;
                } else {
                    scores.ai++;
                    aiScoreElement.textContent = scores.ai;
                }
                
                // Show win message
                const winMessage = winner === 'X' ? 'You win!' : 'AI wins!';
                updateGameStatus(winMessage);
                
                // Draw win line
                drawWinLine();
                
                // Show confetti
                createConfetti();
            }
            
            // Handle draw
            function handleDraw() {
                gameActive = false;
                scores.draw++;
                drawScoreElement.textContent = scores.draw;
                updateGameStatus('Draw!');
            }
            
            // Draw win line
            function drawWinLine() {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6]             // diagonals
                ];
                
                // Find the winning pattern
                const winningPattern = winPatterns.find(pattern => {
                    const [a, b, c] = pattern;
                    return board[a] !== '' && board[a] === board[b] && board[b] === board[c];
                });
                
                if (!winningPattern) return;
                
                const [a, b, c] = winningPattern;
                
                // Calculate line position and rotation
                const boardRect = boardElement.getBoundingClientRect();
                const cellSize = boardRect.width / 3;
                
                // Get positions of the first and last cell in the winning pattern
                const firstCell = boardElement.children[a].getBoundingClientRect();
                const lastCell = boardElement.children[c].getBoundingClientRect();
                
                // Create line element
                const line = document.createElement('div');
                line.classList.add('win-line');
                
                // Set line color based on winner
                line.style.background = currentPlayer === 'X' ? 'rgba(96, 165, 250, 0.7)' : 'rgba(236, 72, 153, 0.7)';
                
                // Position the line
                if (a === 0 && c === 2) { // top row
                    line.style.top = `${cellSize / 2 - 4}px`;
                    line.style.left = '0';
                    line.style.width = '100%';
                } else if (a === 3 && c === 5) { // middle row
                    line.style.top = `${cellSize * 1.5 - 4}px`;
                    line.style.left = '0';
                    line.style.width = '100%';
                } else if (a === 6 && c === 8) { // bottom row
                    line.style.top = `${cellSize * 2.5 - 4}px`;
                    line.style.left = '0';
                    line.style.width = '100%';
                } else if (a === 0 && c === 6) { // left column
                    line.style.left = `${cellSize / 2 - 4}px`;
                    line.style.top = '0';
                    line.style.width = '8px';
                    line.style.height = '100%';
                } else if (a === 1 && c === 7) { // middle column
                    line.style.left = `${cellSize * 1.5 - 4}px`;
                    line.style.top = '0';
                    line.style.width = '8px';
                    line.style.height = '100%';
                } else if (a === 2 && c === 8) { // right column
                    line.style.left = `${cellSize * 2.5 - 4}px`;
                    line.style.top = '0';
                    line.style.width = '8px';
                    line.style.height = '100%';
                } else if (a === 0 && c === 8) { // diagonal top-left to bottom-right
                    line.style.top = '0';
                    line.style.left = '0';
                    line.style.width = '100%';
                    line.style.height = '8px';
                    line.style.transform = 'rotate(45deg)';
                    line.style.transformOrigin = '0 0';
                    line.style.width = `${Math.sqrt(2) * 100}%`;
                } else if (a === 2 && c === 6) { // diagonal top-right to bottom-left
                    line.style.top = '0';
                    line.style.right = '0';
                    line.style.width = '100%';
                    line.style.height = '8px';
                    line.style.transform = 'rotate(-45deg)';
                    line.style.transformOrigin = '100% 0';
                    line.style.width = `${Math.sqrt(2) * 100}%`;
                }
                
                winLineContainer.appendChild(line);
            }
            
            // Create confetti effect
            function createConfetti() {
                const colors = ['#3b82f6', '#ec4899', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444'];
                const confettiCount = 50;
                
                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.classList.add('confetti');
                    
                    // Random properties
                    const size = Math.random() * 10 + 5;
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    const left = Math.random() * 100;
                    const animationDuration = Math.random() * 3 + 2;
                    const delay = Math.random() * 2;
                    
                    // Apply properties
                    confetti.style.width = `${size}px`;
                    confetti.style.height = `${size}px`;
                    confetti.style.left = `${left}%`;
                    confetti.style.top = '-10px';
                    confetti.style.setProperty('--color', color);
                    confetti.style.animationDuration = `${animationDuration}s`;
                    confetti.style.animationDelay = `${delay}s`;
                    
                    // Add to container
                    winLineContainer.appendChild(confetti);
                    
                    // Remove after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, (animationDuration + delay) * 1000);
                }
            }
            
            // AI move logic
            function getAIMove() {
                // Easy difficulty - random moves
                if (difficulty === 'easy') {
                    return getRandomMove();
                }
                
                // Medium difficulty - sometimes blocks or wins, sometimes random
                if (difficulty === 'medium') {
                    // 60% chance to make a smart move, 40% random
                    if (Math.random() < 0.6) {
                        // Check for winning move
                        const winningMove = findWinningMove('O');
                        if (winningMove !== -1) return winningMove;
                        
                        // Check for blocking move
                        const blockingMove = findWinningMove('X');
                        if (blockingMove !== -1) return blockingMove;
                    }
                    
                    return getRandomMove();
                }
                
                // Hard difficulty - perfect AI using minimax
                if (difficulty === 'hard') {
                    return getBestMove();
                }
                
                // Default to random if something goes wrong
                return getRandomMove();
            }
            
            // Find a winning move for the given player
            function findWinningMove(player) {
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        // Try the move
                        board[i] = player;
                        
                        // Check if this move wins
                        if (checkWin(board, player)) {
                            // Undo the move
                            board[i] = '';
                            return i;
                        }
                        
                        // Undo the move
                        board[i] = '';
                    }
                }
                
                return -1; // No winning move found
            }
            
            // Get a random available move
            function getRandomMove() {
                const availableMoves = [];
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        availableMoves.push(i);
                    }
                }
                
                return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
            
            // Minimax algorithm for perfect AI
            function getBestMove() {
                // If center is available, take it (best first move)
                if (board[4] === '') return 4;
                
                // Use minimax to find best move
                let bestScore = -Infinity;
                let bestMove = -1;
                
                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        const score = minimax(board, 0, false);
                        board[i] = '';
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }
                
                return bestMove;
            }
            
            // Minimax helper function
            function minimax(board, depth, isMaximizing) {
                // Check terminal states
                if (checkWin(board, 'O')) return 10 - depth;
                if (checkWin(board, 'X')) return depth - 10;
                if (checkDraw()) return 0;
                
                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'O';
                            const score = minimax(board, depth + 1, false);
                            board[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (board[i] === '') {
                            board[i] = 'X';
                            const score = minimax(board, depth + 1, true);
                            board[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            }
            
            // Reset game
            function resetGame() {
                board = ['', '', '', '', '', '', '', '', ''];
                currentPlayer = 'X';
                gameActive = true;
                
                // Clear board display
                Array.from(boardElement.children).forEach(cell => {
                    cell.textContent = '';
                    cell.classList.remove('text-blue-400', 'text-pink-400');
                });
                
                // Clear win line and confetti
                winLineContainer.innerHTML = '';
                
                // Update status
                updateGameStatus('Your turn (X)');
            }
            
            // Update game status message
            function updateGameStatus(message) {
                gameStatusElement.textContent = message;
                
                // Add glow effect for win/draw messages
                if (message.includes('win!') || message.includes('Draw!')) {
                    gameStatusElement.classList.add('glow');
                } else {
                    gameStatusElement.classList.remove('glow');
                }
            }
            
            // Set difficulty
            function setDifficulty(selectedDifficulty) {
                difficulty = selectedDifficulty;
                
                // Update UI
                difficultyButtons.forEach(btn => {
                    if (btn.dataset.difficulty === selectedDifficulty) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                // Reset game when changing difficulty
                resetGame();
            }
            
            // Set theme
            function setTheme(selectedTheme) {
                theme = selectedTheme;
                
                // Update UI
                themeSelectors.forEach(selector => {
                    if (selector.dataset.theme === selectedTheme) {
                        selector.classList.add('active');
                    } else {
                        selector.classList.remove('active');
                    }
                });
                
                // Apply theme to body
                switch (selectedTheme) {
                    case 'blue':
                        bodyElement.className = 'bg-gradient-to-br from-blue-900 to-blue-700 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                    case 'purple':
                        bodyElement.className = 'bg-gradient-to-br from-purple-900 to-purple-700 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                    case 'green':
                        bodyElement.className = 'bg-gradient-to-br from-green-900 to-green-700 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                    case 'red':
                        bodyElement.className = 'bg-gradient-to-br from-red-900 to-red-700 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                    case 'yellow':
                        bodyElement.className = 'bg-gradient-to-br from-yellow-900 to-yellow-700 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                    default:
                        bodyElement.className = 'bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4 transition-colors duration-500';
                        break;
                }
            }
            
            // Event listeners
            resetBtn.addEventListener('click', resetGame);
            
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    setDifficulty(btn.dataset.difficulty);
                });
            });
            
            themeSelectors.forEach(selector => {
                selector.addEventListener('click', () => {
                    setTheme(selector.dataset.theme);
                });
            });
            
            // Initialize
            initializeBoard();
            setDifficulty('medium');
            setTheme('default');
        });
    </script>
</body>
</html>